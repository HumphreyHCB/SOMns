class MultiParadigmBench usingPlatform: platform andHarness: harness = Value (
| private Benchmark = harness Benchmark.
  private actors    = platform actors.
  private processes = platform processes.

  private Array     = platform kernel Array.
  private ValueArray= platform kernel ValueArray.
  private Vector    = platform kernel Vector.
  private Exception = platform kernel Exception.

  private Channel   = processes Channel.
  private Process   = processes Process.

  private Task      = platform threading Task.
  private Mutex     = platform threading Mutex.

  private tx = platform transactions Transaction.
|
)(
  class BenchMain new: repeat = Benchmark <: Value (
  | private repeat =  repeat asInteger. |
  )(
    public benchmark = (
      | completionPP generator json data forecast |

      completionPP:: actors createPromisePair.
      forecast:: (actors createActorFromValue: ForecastActor) <-: new: completionPP resolver.
      data::   (actors createActorFromValue: DataActor) <-: new: forecast repeat: repeat.
      json::   (actors createActorFromValue: JsonInputActor) <-: new: data.
      json <-: start.

      generator:: (actors createActorFromValue: InputGeneratorActor) <-: new: json repeat: repeat.
      generator <-: start.

      ^ completionPP promise
    )

    public verifyResult: result = (
      repeat =   1 ifTrue: [^ (result at: 1) asInteger = 717 and: [ (result at: 2) asInteger = 27 and: [ (result at: 3) asInteger = 1176 ] ] ].
      repeat = 100 ifTrue: [^ (result at: 1) asInteger = 27744 and: [ (result at: 2) asInteger = 18289 and: [ (result at: 3) asInteger = 87525 ] ] ].

      'No result defined for repeat: ' print. repeat println.
      '  Result: ' print. result println.
      ^ false
    )
  )

  private class JsonParseError signalFor: str at: idx = Exception <: Value (
  | public string = str.
    public index  = idx.
  |
    signal
  )(
    public message = (
      ^ 'JSON parse error. Unexpected character at ' + index + ' in "' + string + '".'.
    )
  )

  private class JsonToken new: val with: type = Value (
  | public value = val.
    public type  = type.
  |)()

  (* Tokenizes a stream of incomming strings into JSON tokens.
     The tokens are passed on to the reader of `tokensOut`.

     The incomming stream `stringIn` is expected to be terminated with `nil`.
     After a complete string is tokenized, it will put a `nil` on `tokensOut`,
     too indicate the end of the token sequence. *)
  private class JsonStreamTokenizer new: stringIn and: tokensOut = Process (
  | private stringIn = stringIn.
    private tokensOut = tokensOut.

    private index         ::= 0.
    private captureBuffer ::= ''.
    private captureStart  ::= 0.
    private current       ::= nil.
    private str           ::= nil.
  |)(
    private error = (
      JsonParseError signalFor: str at: index
    )

    private startCapture = (
      captureStart:: index - 1
    )

    private pauseCapture = (
      captureBuffer:: captureBuffer concatenate: (
        input substringFrom: captureStart to: index - 2).
      captureStart:: -1
    )

    private endCapture = (
      | captured |
      '' = captureBuffer
        ifTrue:  [ captured:: str substringFrom: captureStart to: index - 2 ]
        ifFalse: [
          pauseCapture.
          captured:: captureBuffer.
          captureBuffer:: '' ].
      captureStart:: -1.

      ^ captured
    )

    private readDigit = (
      isDigit ifFalse: [ ^ false ].
      read.
      ^ true
    )

    private readNumber = (
      | firstDigit |
      startCapture.
      current = '-' ifTrue: [ read ].
      firstDigit:: current.

      readDigit ifFalse: [ error ].
      firstDigit <> '0' ifTrue: [ [ readDigit ] whileTrue: []].

      readFraction.
      tokensOut write: (JsonToken new: endCapture asInteger with: #number)
    )

    readFraction = (
      (current = '.') ifTrue: [ read ] ifFalse: [ ^ false ].

      readDigit ifFalse: [ error ].

      [ readDigit ] whileTrue: [].

      ^ true
    )

    private readString = (
      | string |
      read.
      startCapture.

      [current = '"'] whileFalse: [
        current = '\\' ifTrue: [
          pauseCapture.
          readEscape.
          startCapture.
        ] ifFalse: [
          (* TODO: if (current < 0x20) { throw expected('valid string character'); }*)
          read.
        ]
      ].
      string:: endCapture.
      tokensOut write: (JsonToken new: string with: #string).
    )

    private readNull = (
      read = 'u' ifFalse: [ ^ error ].
      read = 'l' ifFalse: [ ^ error ].
      read = 'l' ifFalse: [ ^ error ].
      ^ tokensOut write: (JsonToken new: nil with: #null)
    )

    private readFalse = (
      read = 'a' ifFalse: [ ^ error ].
      read = 'l' ifFalse: [ ^ error ].
      read = 's' ifFalse: [ ^ error ].
      read = 'e' ifFalse: [ ^ error ].
      ^ tokensOut write: (JsonToken new: false with: #false)
    )

    private readTrue = (
      read = 'r' ifFalse: [ ^ error ].
      read = 'u' ifFalse: [ ^ error ].
      read = 'e' ifFalse: [ ^ error ].
      ^ tokensOut write: (JsonToken new: true with: #true)
    )

    private isWhiteSpace = (
      current = ' '  ifTrue: [ ^ true ].
      current = '\t' ifTrue: [ ^ true ].
      current = '\n' ifTrue: [ ^ true ].
      current = '\r' ifTrue: [ ^ true ].
      ^ false
    )

    private isDigit = (
      current = '0' ifTrue: [ ^ true ].
      current = '1' ifTrue: [ ^ true ].
      current = '2' ifTrue: [ ^ true ].
      current = '3' ifTrue: [ ^ true ].
      current = '4' ifTrue: [ ^ true ].
      current = '5' ifTrue: [ ^ true ].
      current = '6' ifTrue: [ ^ true ].
      current = '7' ifTrue: [ ^ true ].
      current = '8' ifTrue: [ ^ true ].
      current = '9' ifTrue: [ ^ true ].
      ^ false
    )

    private readToken = (
      current = '{' ifTrue: [ ^ tokensOut write: (JsonToken new: current with: #leftBrace)    ].
      current = '}' ifTrue: [ ^ tokensOut write: (JsonToken new: current with: #rightBrace)   ].
      current = '[' ifTrue: [ ^ tokensOut write: (JsonToken new: current with: #leftBracket)  ].
      current = ']' ifTrue: [ ^ tokensOut write: (JsonToken new: current with: #rightBracket) ].
      current = ':' ifTrue: [ ^ tokensOut write: (JsonToken new: current with: #colon) ].
      current = ',' ifTrue: [ ^ tokensOut write: (JsonToken new: current with: #comma) ].
      current = '"' ifTrue: [ ^ readString ].
      current = 't' ifTrue: [ ^ readTrue ].
      current = 'f' ifTrue: [ ^ readFalse ].
      current = 'n' ifTrue: [ ^ readNull ].
      isDigit ifTrue: [ ^ readNumber ].
      isWhiteSpace ifFalse: [
        error ].
    )

    (* read next character *)
    private read = (
      current:: str charAt: index.
      index::   index + 1.
      ^ current
    )

    private tokenize: str = (
      index:: 1.

      [ index <= str length ] whileTrue: [
        read.
        readToken ].

      tokensOut write: nil. (* signal end of chunk *)
    )

    public run = (
      [ str:: stringIn read. str = nil ] whileFalse: [
        tokenize: str ].
      tokensOut write: #end. (* signal end of stream *)
    )
  )

  private class RelevantData price: price quantity: quantity item: item = Value (
  | public price    = price.
    public quantity = quantity.
    public item     = item.
  |)(
    public total = ( ^ price * quantity )
  )

  private class DataFilterProcess new: tokensIn data: dataOut = Process (
  | private tokensIn = tokensIn.
    private dataOut  = dataOut.

    private priceNext    ::= false.
    private quantityNext ::= false.
    private itemNext     ::= false.
    private price        ::= -1.
    private quantity     ::= -1.
    private item         ::= nil.
  |)(
    private parseStr: token = (
      itemNext ifTrue: [
        item:: token value.
        ^ itemNext:: false ].
      token value = 'price' ifTrue: [ ^ priceNext:: true ].
      token value = 'quantity' ifTrue: [ ^ quantityNext:: true ].
      token value = 'item'     ifTrue: [ ^ itemNext:: true ].
    )
    private process: token = (
      token type = #string ifTrue: [ ^ parseStr: token ].
      token type = #number ifTrue: [
        priceNext ifTrue: [ price:: token value. priceNext:: false ].
        quantityNext ifTrue: [ quantity:: token value. quantityNext:: false ] ].
    )

    public run = (
      | token |
      [ token:: tokensIn read. #end <> token ] whileTrue: [
        token isNil
          ifTrue:  [
             dataOut write: (RelevantData price: price quantity: quantity item: item) ]
          ifFalse: [ process: token ] ]
    )
  )

  class BlackHoleOut = Value ()(
    public write: v = ( v total )
  )

  (* Actor to hide the CSP-based implementation from the rest of the system. *)
  class JsonInputActor new: dataActor = (
  | private dataActor = dataActor.
    private stringOut ::= nil.
    private dataIn ::= nil.
  |)(
    (* Initializes the subsystem *)
    public start = (
      | toTokenizer toObjectCtor toDataStore |
      toTokenizer::  Channel new.
      toObjectCtor:: Channel new.
      toDataStore::  Channel new.
      stringOut:: toTokenizer out.
      dataIn::    toDataStore in.

      processes spawn: JsonStreamTokenizer with: { toTokenizer in. toObjectCtor out }.
      processes spawn: DataFilterProcess   with: { toObjectCtor in. toDataStore out }.
    )

    public stream: str = (
      (* Careful, this is blocking. We don't have proper language integration yet.
         TODO: revise in nice language, future work.
       *)
      stringOut write: str.
      (* this is blocking, too. *)
      str notNil ifTrue: [
        dataActor <-: data: dataIn read ]
    )
  )

  (* Actor generating input for the whole system *)
  class InputGeneratorActor new: jsonInput repeat: anInt = (
  | private jsonInput = jsonInput.
    private repeat    = anInt.
  |)(
    private jsonStreamInput = (
      ^ { '{"price":10,"quantity": 87,"customer": "Medesign","address":"993 Kensington Walk, Cassel, Tennessee, 8882","item": "strawberry"}'.
          '{"price": 5,"quantity": 83,"customer": "Gadtron","address": "652 Coffey Street, Oasis, Rhode Island, 8428","item": "apple"}'.
          '{"price": 5,"quantity": 20,"customer": "Rooforia","address": "117 Holmes Lane, Innsbrook, Connecticut, 4261","item": "banana"}'.
          '{"price": 4,"quantity": 18,"customer": "Sureplex","address": "586 Beacon Court, Durham, Louisiana, 1428","item": "apple"}'.
          '{"price": 2,"quantity": 39,"customer": "Spherix","address": "489 Beaver Street, Elbert, Florida, 3946","item": "strawberry"}'.
          '{"price": 8,"quantity": 33,"customer": "Podunk","address": "126 Concord Street, Westwood, Kansas, 2573","item": "banana"}'.
          '{"price": 1,"quantity": 31,"customer": "Malathion","address": "202 Newport Street, Boyd, Oklahoma, 4821","item": "strawberry"}'.
          '{"price": 3,"quantity": 48,"customer": "Illumity","address": "996 George Street, Bennett, Illinois, 1760","item": "strawberry"}'.
          '{"price": 2,"quantity": 33,"customer": "Accupharm","address": "654 Court Square, Kohatk, Indiana, 5110","item": "apple"}'.
          '{"price": 8,"quantity": 78,"customer": "Terascape","address": "767 Thatford Avenue, Sunbury, Delaware, 4729","item": "strawberry"}' }
    )

    public start = (
      repeat timesRepeat: [
        jsonStreamInput do: [:str |
          jsonInput <-: stream: str. #noPromise (* just suppressing the promise *) ] ].
      jsonInput <-: stream: nil. (* signal end of stream *)
    )
  )

  class DataActor new: forecastActor repeat: repeat = (
  | private dataItems      = repeat * 10.
    private dataStrawberry = Vector new: repeat * 5.
    private dataApple      = Vector new: repeat * 3.
    private dataBanana     = Vector new: repeat * 2.
    private forecastActor = forecastActor.
    private receivedItems ::= 0.
  |)(
    private updateDataStore: aRelevantDatum = (
      aRelevantDatum item = 'strawberry' ifTrue: [
        tx atomic: [
          dataStrawberry append: aRelevantDatum.
          receivedItems:: receivedItems + 1 ].
        ^ self ].

      aRelevantDatum item = 'apple' ifTrue: [
        tx atomic: [
          dataApple append: aRelevantDatum.
          receivedItems:: receivedItems + 1 ].
        ^ self ].

      aRelevantDatum item = 'banana' ifTrue: [
        tx atomic: [
          dataBanana append: aRelevantDatum.
          receivedItems:: receivedItems + 1 ].
        ^ self ].
    )

    public data: aRelevantDatum = (
      updateDataStore: aRelevantDatum.
      receivedItems = dataItems
        ifTrue: [ sendForecast ]
    )

    (* Select data for forecasting and send it to `forecastActor`. *)
    private sendForecast = (
      | valArrS valArrA valArrB |
      valArrS:: ValueArray new: dataStrawberry size
                       withAll: [:i | (dataStrawberry at: i) total ].
      valArrA:: ValueArray new: dataApple size
                       withAll: [:i | (dataApple at: i) total ].
      valArrB:: ValueArray new: dataBanana size
                       withAll: [:i | (dataBanana at: i) total ].

      forecastActor <-: forecastS: valArrS a: valArrA b: valArrB
    )
  )

  class ForecastActor new: resolver = (
  | private resolver = resolver. |
  )(
    private linearRegression: values = (
      | sumX sumY sumXSquare xMean yMean xx xy slope intercept |
      sumX:: 0.0.
      sumY:: 0.0.
      sumXSquare:: 0.0.

      values doIndexes: [:x |
        | y = values at: x. |
        sumX:: sumX + x.
        sumXSquare:: sumXSquare + (x * x).
        sumY:: sumY + y. ].

      xMean:: sumX // values size.
      yMean:: sumY // values size.

      xx:: 0.0.
      xy:: 0.0.

      values doIndexes: [:x |
        | y = values at: x. |
        xx:: xx + ((x - xMean) * (x - xMean)).
        xy:: xy + ((x - xMean) * (y - yMean)).
      ].

      slope:: xy // xx.
      intercept:: yMean - slope * xMean.
      ^ {slope. intercept}
    )


    public forecastS: arrS a: arrA b: arrB = (
      | linearRegs = Array new: 3. mtx = Mutex new. t1 t2 t3 |

      t1:: Task spawn: [
        | result = linearRegression: arrA. |
        mtx critical: [
          linearRegs at: 1 put: result ] ].

      t2:: Task spawn: [
        | result = linearRegression: arrB. |
        mtx critical: [
          linearRegs at: 2 put: result ] ].

      t3:: Task spawn: [
        | result = linearRegression: arrS. |
        mtx critical: [
          linearRegs at: 3 put: result ] ].

      (* linearRegs do: [:lr |
        ((lr at: 1) asString + ' . ' + (lr at: 2) asString) println ]. *)
      t1 join.
      t2 join.
      t3 join.

      (* End Demo *)
      resolver resolve: (ValueArray new: 3 withAll: [:i | (linearRegs at: i) at: 2 ])
    )
  )

  public newInstance: problemSize = ( ^ BenchMain new: problemSize )
)
